name: Production

# Ce workflow se déclenche automatiquement lors d'un push sur la branche main
on:
  push:
    branches:
      - main

# Variables d'environnement partagées par tous les jobs
env:
  REGISTRY: ghcr.io # GitHub Container Registry - où sont stockées nos images Docker
  IMAGE_NAME: ${{ github.repository }} # Nom du repository GitHub (ex: aboubacar3012/santu-hub-cicd-example)

jobs:
  # Construction et publication de l'image Docker sur GitHub Container Registry
  build-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      pull-requests: read
      actions: read

    steps:
      # Télécharger le code source du commit
      - name: Checkout repository
        uses: actions/checkout@v4

      # Supprimer l'ancien fichier .env s'il existe
      - name: Clean old .env file
        run: rm -f .env

      # Créer le fichier .env avec les variables GitHub
      - name: Create .env file from GitHub variables
        run: |
          {
            echo "VARIABLE1=${VARIABLE1}"
            echo "VARIABLE2=${VARIABLE2}"
            echo "VARIABLE3=${VARIABLE3}"
          } > .env
        env:
          VARIABLE1: ${{ vars.VARIABLE1 }}
          VARIABLE2: ${{ vars.VARIABLE2 }}
          VARIABLE3: ${{ vars.VARIABLE3 }}

      # Afficher le contenu du fichier .env pour débugger
      - name: Debug .env
        run: |
          echo "------ Contenu de .env ------"
          cat .env
          echo "----------------------------------------"

      # Se connecter au registre Docker GitHub Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.PAT_GITHUB_TOKEN }}

      # Rendre le script exécutable
      - name: Make script executable
        run: chmod +x build-image.sh

      # Construire et publier l'image Docker sur GitHub Container Registry
      - name: Build and push image
        run: ./build-image.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Déploiement de l'application sur le serveur de production
  deploy:
    runs-on: ubuntu-latest
    needs: [build-image]

    steps:
      # Se connecter au serveur et déployer l'application
      - name: Deploy to production server
        if: needs.build-image.result == 'success'
        shell: bash
        run: |
          set -eo pipefail

          # Créer le dossier SSH et configurer la clé privée
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Se connecter au serveur production via SSH et exécuter les commandes de déploiement
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key -p ${{ secrets.SSH_PORT }} ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} << EOF
            CONTAINER_NAME="${{ github.event.repository.name }}"
            IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
            
            echo "Authentification à GitHub Container Registry..."
            echo "${{ secrets.PAT_GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            echo "Arrêt et suppression du conteneur existant s'il existe..."
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
            docker rmi $IMAGE_TAG || true
            
            echo "Récupération de l'image..."
            docker pull $IMAGE_TAG
            
            echo "Démarrage du conteneur..."
            docker run -d --name $CONTAINER_NAME -p 3000:3000 --restart unless-stopped $IMAGE_TAG

            echo "Vérification du statut du conteneur..."
            docker ps | grep $CONTAINER_NAME
          EOF
          echo "Déploiement terminé"

      # Message de succès
      - name: Deployment success
        run: echo "Déploiement terminé avec succès."
        if: success()
